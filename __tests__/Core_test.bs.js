// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Jest from "@glennsl/bs-jest/src/jest.bs.js";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Caml_array from "rescript/lib/es6/caml_array.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core$Scrollock from "../src/Core.bs.js";

function beforeEach$1(prim) {
  beforeEach(function () {
        return Curry._1(prim, undefined);
      });
  
}

function mock(prim) {
  jest.mock(prim);
  
}

var expect = Jest.Expect.expect;

jest.mock("body-scroll-lock");

Jest.describe("Test Core", (function (param) {
        Jest.describe("When the onBodyScrollLock callback is passed", (function (param) {
                var mockOnBodyScrollLockRef = {
                  contents: undefined
                };
                var scrollockCoreRef = {
                  contents: undefined
                };
                var targetElement1Ref = {
                  contents: undefined
                };
                beforeEach(function () {
                      var mockOnBodyScrollLock = jest.fn(function (param) {
                            
                          });
                      mockOnBodyScrollLockRef.contents = Caml_option.some(mockOnBodyScrollLock);
                      scrollockCoreRef.contents = Caml_option.some(Core$Scrollock.make({
                                onBodyScrollLock: mockOnBodyScrollLock,
                                onBodyScrollUnlock: undefined,
                                onLockTargetsAdd: undefined,
                                onLockTargetsRemove: undefined
                              }));
                      targetElement1Ref.contents = Caml_option.some(document.createElement("div"));
                      
                    });
                Jest.test("Isn't called right after creation", (function (param) {
                        var match = mockOnBodyScrollLockRef.contents;
                        var match$1 = scrollockCoreRef.contents;
                        if (match === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        if (match$1 === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        var __x = expect(Jest.MockJs.calls(Caml_option.valFromOption(match)).length);
                        return Jest.Expect.toBe(0, __x);
                      }));
                Jest.test("Is called after first lock", (function (param) {
                        var match = mockOnBodyScrollLockRef.contents;
                        var match$1 = scrollockCoreRef.contents;
                        var match$2 = targetElement1Ref.contents;
                        if (match === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        if (match$1 === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        if (match$2 === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        Core$Scrollock.lock(Caml_option.valFromOption(match$1), [Caml_option.valFromOption(match$2)]);
                        var __x = expect(Jest.MockJs.calls(Caml_option.valFromOption(match)).length);
                        return Jest.Expect.toBe(1, __x);
                      }));
                Jest.test("Isn't called once again after unlock", (function (param) {
                        var match = mockOnBodyScrollLockRef.contents;
                        var match$1 = scrollockCoreRef.contents;
                        var match$2 = targetElement1Ref.contents;
                        if (match === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        if (match$1 === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        if (match$2 === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        var targetElement1 = Caml_option.valFromOption(match$2);
                        var scrollockCore = Caml_option.valFromOption(match$1);
                        Core$Scrollock.lock(scrollockCore, [targetElement1]);
                        Core$Scrollock.unlock(scrollockCore, [targetElement1]);
                        var __x = expect(Jest.MockJs.calls(Caml_option.valFromOption(match)).length);
                        return Jest.Expect.toBe(1, __x);
                      }));
                Jest.test("Is called once again after second lock", (function (param) {
                        var match = mockOnBodyScrollLockRef.contents;
                        var match$1 = scrollockCoreRef.contents;
                        var match$2 = targetElement1Ref.contents;
                        if (match === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        if (match$1 === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        if (match$2 === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        var targetElement1 = Caml_option.valFromOption(match$2);
                        var scrollockCore = Caml_option.valFromOption(match$1);
                        Core$Scrollock.lock(scrollockCore, [targetElement1]);
                        Core$Scrollock.unlock(scrollockCore, [targetElement1]);
                        Core$Scrollock.lock(scrollockCore, [targetElement1]);
                        var __x = expect(Jest.MockJs.calls(Caml_option.valFromOption(match)).length);
                        return Jest.Expect.toBe(2, __x);
                      }));
                Jest.test("Isn't called multiple times after locking multiple elements", (function (param) {
                        var match = mockOnBodyScrollLockRef.contents;
                        var match$1 = scrollockCoreRef.contents;
                        var match$2 = targetElement1Ref.contents;
                        if (match === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        if (match$1 === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        if (match$2 === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        var scrollockCore = Caml_option.valFromOption(match$1);
                        var targetElement2 = document.createElement("div");
                        Core$Scrollock.lock(scrollockCore, [Caml_option.valFromOption(match$2)]);
                        Core$Scrollock.lock(scrollockCore, [targetElement2]);
                        var __x = expect(Jest.MockJs.calls(Caml_option.valFromOption(match)).length);
                        return Jest.Expect.toBe(1, __x);
                      }));
                return Jest.test("Is called once again after clearing multiple locks and locking again", (function (param) {
                              var match = mockOnBodyScrollLockRef.contents;
                              var match$1 = scrollockCoreRef.contents;
                              var match$2 = targetElement1Ref.contents;
                              if (match === undefined) {
                                return Jest.fail("Prepare stage failed");
                              }
                              if (match$1 === undefined) {
                                return Jest.fail("Prepare stage failed");
                              }
                              if (match$2 === undefined) {
                                return Jest.fail("Prepare stage failed");
                              }
                              var targetElement1 = Caml_option.valFromOption(match$2);
                              var scrollockCore = Caml_option.valFromOption(match$1);
                              var targetElement2 = document.createElement("div");
                              Core$Scrollock.lock(scrollockCore, [targetElement1]);
                              Core$Scrollock.lock(scrollockCore, [targetElement2]);
                              Core$Scrollock.clear(scrollockCore);
                              Core$Scrollock.lock(scrollockCore, [targetElement1]);
                              var __x = expect(Jest.MockJs.calls(Caml_option.valFromOption(match)).length);
                              return Jest.Expect.toBe(2, __x);
                            }));
              }));
        Jest.describe("When the onBodyScrollUnlock callback is passed", (function (param) {
                var mockOnBodyScrollUnlockRef = {
                  contents: undefined
                };
                var scrollockCoreRef = {
                  contents: undefined
                };
                var targetElement1Ref = {
                  contents: undefined
                };
                beforeEach(function () {
                      var mockOnBodyScrollUnlock = jest.fn(function (param) {
                            
                          });
                      mockOnBodyScrollUnlockRef.contents = Caml_option.some(mockOnBodyScrollUnlock);
                      scrollockCoreRef.contents = Caml_option.some(Core$Scrollock.make({
                                onBodyScrollLock: undefined,
                                onBodyScrollUnlock: mockOnBodyScrollUnlock,
                                onLockTargetsAdd: undefined,
                                onLockTargetsRemove: undefined
                              }));
                      targetElement1Ref.contents = Caml_option.some(document.createElement("div"));
                      
                    });
                Jest.test("Isn't called right after creation", (function (param) {
                        var match = mockOnBodyScrollUnlockRef.contents;
                        var match$1 = scrollockCoreRef.contents;
                        if (match === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        if (match$1 === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        var __x = expect(Jest.MockJs.calls(Caml_option.valFromOption(match)).length);
                        return Jest.Expect.toBe(0, __x);
                      }));
                Jest.test("Isn't called after lock", (function (param) {
                        var match = mockOnBodyScrollUnlockRef.contents;
                        var match$1 = scrollockCoreRef.contents;
                        var match$2 = targetElement1Ref.contents;
                        if (match === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        if (match$1 === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        if (match$2 === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        Core$Scrollock.lock(Caml_option.valFromOption(match$1), [Caml_option.valFromOption(match$2)]);
                        var __x = expect(Jest.MockJs.calls(Caml_option.valFromOption(match)).length);
                        return Jest.Expect.toBe(0, __x);
                      }));
                Jest.test("Is called after unlock", (function (param) {
                        var match = mockOnBodyScrollUnlockRef.contents;
                        var match$1 = scrollockCoreRef.contents;
                        var match$2 = targetElement1Ref.contents;
                        if (match === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        if (match$1 === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        if (match$2 === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        var targetElement1 = Caml_option.valFromOption(match$2);
                        var scrollockCore = Caml_option.valFromOption(match$1);
                        Core$Scrollock.lock(scrollockCore, [targetElement1]);
                        Core$Scrollock.unlock(scrollockCore, [targetElement1]);
                        var __x = expect(Jest.MockJs.calls(Caml_option.valFromOption(match)).length);
                        return Jest.Expect.toBe(1, __x);
                      }));
                Jest.test("Is called after clear", (function (param) {
                        var match = mockOnBodyScrollUnlockRef.contents;
                        var match$1 = scrollockCoreRef.contents;
                        var match$2 = targetElement1Ref.contents;
                        if (match === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        if (match$1 === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        if (match$2 === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        var scrollockCore = Caml_option.valFromOption(match$1);
                        Core$Scrollock.lock(scrollockCore, [Caml_option.valFromOption(match$2)]);
                        Core$Scrollock.clear(scrollockCore);
                        var __x = expect(Jest.MockJs.calls(Caml_option.valFromOption(match)).length);
                        return Jest.Expect.toBe(1, __x);
                      }));
                Jest.test("Is called after clearing multiple locks", (function (param) {
                        var match = mockOnBodyScrollUnlockRef.contents;
                        var match$1 = scrollockCoreRef.contents;
                        var match$2 = targetElement1Ref.contents;
                        if (match === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        if (match$1 === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        if (match$2 === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        var scrollockCore = Caml_option.valFromOption(match$1);
                        var targetElement2 = document.createElement("div");
                        Core$Scrollock.lock(scrollockCore, [Caml_option.valFromOption(match$2)]);
                        Core$Scrollock.lock(scrollockCore, [targetElement2]);
                        Core$Scrollock.clear(scrollockCore);
                        var __x = expect(Jest.MockJs.calls(Caml_option.valFromOption(match)).length);
                        return Jest.Expect.toBe(1, __x);
                      }));
                Jest.test("Is called once again after second unlock", (function (param) {
                        var match = mockOnBodyScrollUnlockRef.contents;
                        var match$1 = scrollockCoreRef.contents;
                        var match$2 = targetElement1Ref.contents;
                        if (match === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        if (match$1 === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        if (match$2 === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        var targetElement1 = Caml_option.valFromOption(match$2);
                        var scrollockCore = Caml_option.valFromOption(match$1);
                        Core$Scrollock.lock(scrollockCore, [targetElement1]);
                        Core$Scrollock.unlock(scrollockCore, [targetElement1]);
                        Core$Scrollock.lock(scrollockCore, [targetElement1]);
                        Core$Scrollock.unlock(scrollockCore, [targetElement1]);
                        var __x = expect(Jest.MockJs.calls(Caml_option.valFromOption(match)).length);
                        return Jest.Expect.toBe(2, __x);
                      }));
                Jest.test("Isn't called after locking multiple elements and unlocking some of them", (function (param) {
                        var match = mockOnBodyScrollUnlockRef.contents;
                        var match$1 = scrollockCoreRef.contents;
                        var match$2 = targetElement1Ref.contents;
                        if (match === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        if (match$1 === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        if (match$2 === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        var scrollockCore = Caml_option.valFromOption(match$1);
                        var targetElement2 = document.createElement("div");
                        Core$Scrollock.lock(scrollockCore, [Caml_option.valFromOption(match$2)]);
                        Core$Scrollock.lock(scrollockCore, [targetElement2]);
                        Core$Scrollock.unlock(scrollockCore, [targetElement2]);
                        var __x = expect(Jest.MockJs.calls(Caml_option.valFromOption(match)).length);
                        return Jest.Expect.toBe(0, __x);
                      }));
                return Jest.test("Isn't called after unlocking while body scroll isn't locked", (function (param) {
                              var match = mockOnBodyScrollUnlockRef.contents;
                              var match$1 = scrollockCoreRef.contents;
                              var match$2 = targetElement1Ref.contents;
                              if (match === undefined) {
                                return Jest.fail("Prepare stage failed");
                              }
                              if (match$1 === undefined) {
                                return Jest.fail("Prepare stage failed");
                              }
                              if (match$2 === undefined) {
                                return Jest.fail("Prepare stage failed");
                              }
                              Core$Scrollock.unlock(Caml_option.valFromOption(match$1), [Caml_option.valFromOption(match$2)]);
                              var __x = expect(Jest.MockJs.calls(Caml_option.valFromOption(match)).length);
                              return Jest.Expect.toBe(0, __x);
                            }));
              }));
        Jest.describe("When the onLockTargetsAdd callback is passed", (function (param) {
                var mockOnLockTargetsAddRef = {
                  contents: undefined
                };
                var scrollockCoreRef = {
                  contents: undefined
                };
                var targetElement1Ref = {
                  contents: undefined
                };
                beforeEach(function () {
                      var mockOnLockTargetsAdd = jest.fn(function (param) {
                            
                          });
                      mockOnLockTargetsAddRef.contents = Caml_option.some(mockOnLockTargetsAdd);
                      scrollockCoreRef.contents = Caml_option.some(Core$Scrollock.make({
                                onBodyScrollLock: undefined,
                                onBodyScrollUnlock: undefined,
                                onLockTargetsAdd: mockOnLockTargetsAdd,
                                onLockTargetsRemove: undefined
                              }));
                      targetElement1Ref.contents = Caml_option.some(document.createElement("div"));
                      
                    });
                Jest.test("Isn't called right after creation", (function (param) {
                        var match = mockOnLockTargetsAddRef.contents;
                        var match$1 = scrollockCoreRef.contents;
                        if (match === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        if (match$1 === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        var __x = expect(Jest.MockJs.calls(Caml_option.valFromOption(match)).length);
                        return Jest.Expect.toBe(0, __x);
                      }));
                Jest.test("Is called once after lock call", (function (param) {
                        var match = mockOnLockTargetsAddRef.contents;
                        var match$1 = scrollockCoreRef.contents;
                        var match$2 = targetElement1Ref.contents;
                        if (match === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        if (match$1 === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        if (match$2 === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        Core$Scrollock.lock(Caml_option.valFromOption(match$1), [Caml_option.valFromOption(match$2)]);
                        var __x = expect(Jest.MockJs.calls(Caml_option.valFromOption(match)).length);
                        return Jest.Expect.toBe(1, __x);
                      }));
                Jest.test("Is called once after lock call with multiple targetElements", (function (param) {
                        var match = mockOnLockTargetsAddRef.contents;
                        var match$1 = scrollockCoreRef.contents;
                        var match$2 = targetElement1Ref.contents;
                        if (match === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        if (match$1 === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        if (match$2 === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        var targetElement2 = document.createElement("div");
                        Core$Scrollock.lock(Caml_option.valFromOption(match$1), [
                              Caml_option.valFromOption(match$2),
                              targetElement2
                            ]);
                        var __x = expect(Jest.MockJs.calls(Caml_option.valFromOption(match)).length);
                        return Jest.Expect.toBe(1, __x);
                      }));
                Jest.test("Is called with provided targetElements", (function (param) {
                        var match = mockOnLockTargetsAddRef.contents;
                        var match$1 = scrollockCoreRef.contents;
                        var match$2 = targetElement1Ref.contents;
                        if (match === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        if (match$1 === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        if (match$2 === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        var targetElement1 = Caml_option.valFromOption(match$2);
                        var targetElement2 = document.createElement("div");
                        Core$Scrollock.lock(Caml_option.valFromOption(match$1), [
                              targetElement1,
                              targetElement2
                            ]);
                        var __x = expect(Caml_array.get(Jest.MockJs.calls(Caml_option.valFromOption(match)), 0));
                        return Jest.Expect.toEqual([
                                    targetElement1,
                                    targetElement2
                                  ], __x);
                      }));
                Jest.test("Is called with the only instance of targetElement if there are multiple same instances in the lock function", (function (param) {
                        var match = mockOnLockTargetsAddRef.contents;
                        var match$1 = scrollockCoreRef.contents;
                        var match$2 = targetElement1Ref.contents;
                        if (match === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        if (match$1 === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        if (match$2 === undefined) {
                          return Jest.fail("Prepare stage failed");
                        }
                        var targetElement1 = Caml_option.valFromOption(match$2);
                        Core$Scrollock.lock(Caml_option.valFromOption(match$1), [
                              targetElement1,
                              targetElement1
                            ]);
                        var __x = expect(Caml_array.get(Jest.MockJs.calls(Caml_option.valFromOption(match)), 0));
                        return Jest.Expect.toEqual([targetElement1], __x);
                      }));
                return Jest.test("Isn't called the second time if the targetElement is already locked", (function (param) {
                              var match = mockOnLockTargetsAddRef.contents;
                              var match$1 = scrollockCoreRef.contents;
                              var match$2 = targetElement1Ref.contents;
                              if (match === undefined) {
                                return Jest.fail("Prepare stage failed");
                              }
                              if (match$1 === undefined) {
                                return Jest.fail("Prepare stage failed");
                              }
                              if (match$2 === undefined) {
                                return Jest.fail("Prepare stage failed");
                              }
                              var targetElement1 = Caml_option.valFromOption(match$2);
                              var scrollockCore = Caml_option.valFromOption(match$1);
                              Core$Scrollock.lock(scrollockCore, [targetElement1]);
                              Core$Scrollock.lock(scrollockCore, [targetElement1]);
                              var __x = expect(Jest.MockJs.calls(Caml_option.valFromOption(match)).length);
                              return Jest.Expect.toBe(1, __x);
                            }));
              }));
        return Jest.describe("When the onLockTargetsRemove callback is passed", (function (param) {
                      var mockOnLockTargetsRemoveRef = {
                        contents: undefined
                      };
                      var scrollockCoreRef = {
                        contents: undefined
                      };
                      var targetElement1Ref = {
                        contents: undefined
                      };
                      beforeEach(function () {
                            var mockOnLockTargetsRemove = jest.fn(function (param) {
                                  
                                });
                            mockOnLockTargetsRemoveRef.contents = Caml_option.some(mockOnLockTargetsRemove);
                            scrollockCoreRef.contents = Caml_option.some(Core$Scrollock.make({
                                      onBodyScrollLock: undefined,
                                      onBodyScrollUnlock: undefined,
                                      onLockTargetsAdd: undefined,
                                      onLockTargetsRemove: mockOnLockTargetsRemove
                                    }));
                            targetElement1Ref.contents = Caml_option.some(document.createElement("div"));
                            
                          });
                      Jest.test("Isn't called right after creation", (function (param) {
                              var match = mockOnLockTargetsRemoveRef.contents;
                              var match$1 = scrollockCoreRef.contents;
                              if (match === undefined) {
                                return Jest.fail("Prepare stage failed");
                              }
                              if (match$1 === undefined) {
                                return Jest.fail("Prepare stage failed");
                              }
                              var __x = expect(Jest.MockJs.calls(Caml_option.valFromOption(match)).length);
                              return Jest.Expect.toBe(0, __x);
                            }));
                      Jest.test("Is called once after unlock call", (function (param) {
                              var match = mockOnLockTargetsRemoveRef.contents;
                              var match$1 = scrollockCoreRef.contents;
                              var match$2 = targetElement1Ref.contents;
                              if (match === undefined) {
                                return Jest.fail("Prepare stage failed");
                              }
                              if (match$1 === undefined) {
                                return Jest.fail("Prepare stage failed");
                              }
                              if (match$2 === undefined) {
                                return Jest.fail("Prepare stage failed");
                              }
                              var targetElement1 = Caml_option.valFromOption(match$2);
                              var scrollockCore = Caml_option.valFromOption(match$1);
                              Core$Scrollock.lock(scrollockCore, [targetElement1]);
                              Core$Scrollock.unlock(scrollockCore, [targetElement1]);
                              var __x = expect(Jest.MockJs.calls(Caml_option.valFromOption(match)).length);
                              return Jest.Expect.toBe(1, __x);
                            }));
                      Jest.test("Is called once after unlock call with multiple targetElements", (function (param) {
                              var match = mockOnLockTargetsRemoveRef.contents;
                              var match$1 = scrollockCoreRef.contents;
                              var match$2 = targetElement1Ref.contents;
                              if (match === undefined) {
                                return Jest.fail("Prepare stage failed");
                              }
                              if (match$1 === undefined) {
                                return Jest.fail("Prepare stage failed");
                              }
                              if (match$2 === undefined) {
                                return Jest.fail("Prepare stage failed");
                              }
                              var targetElement1 = Caml_option.valFromOption(match$2);
                              var scrollockCore = Caml_option.valFromOption(match$1);
                              var targetElement2 = document.createElement("div");
                              Core$Scrollock.lock(scrollockCore, [
                                    targetElement1,
                                    targetElement2
                                  ]);
                              Core$Scrollock.unlock(scrollockCore, [
                                    targetElement1,
                                    targetElement2
                                  ]);
                              var __x = expect(Jest.MockJs.calls(Caml_option.valFromOption(match)).length);
                              return Jest.Expect.toBe(1, __x);
                            }));
                      Jest.test("Is called once after clear call of multiple targetElements", (function (param) {
                              var match = mockOnLockTargetsRemoveRef.contents;
                              var match$1 = scrollockCoreRef.contents;
                              var match$2 = targetElement1Ref.contents;
                              if (match === undefined) {
                                return Jest.fail("Prepare stage failed");
                              }
                              if (match$1 === undefined) {
                                return Jest.fail("Prepare stage failed");
                              }
                              if (match$2 === undefined) {
                                return Jest.fail("Prepare stage failed");
                              }
                              var scrollockCore = Caml_option.valFromOption(match$1);
                              var targetElement2 = document.createElement("div");
                              Core$Scrollock.lock(scrollockCore, [
                                    Caml_option.valFromOption(match$2),
                                    targetElement2
                                  ]);
                              Core$Scrollock.clear(scrollockCore);
                              var __x = expect(Jest.MockJs.calls(Caml_option.valFromOption(match)).length);
                              return Jest.Expect.toBe(1, __x);
                            }));
                      Jest.test("Is called with provided targetElements to unlock", (function (param) {
                              var match = mockOnLockTargetsRemoveRef.contents;
                              var match$1 = scrollockCoreRef.contents;
                              var match$2 = targetElement1Ref.contents;
                              if (match === undefined) {
                                return Jest.fail("Prepare stage failed");
                              }
                              if (match$1 === undefined) {
                                return Jest.fail("Prepare stage failed");
                              }
                              if (match$2 === undefined) {
                                return Jest.fail("Prepare stage failed");
                              }
                              var targetElement1 = Caml_option.valFromOption(match$2);
                              var scrollockCore = Caml_option.valFromOption(match$1);
                              var targetElement2 = document.createElement("div");
                              Core$Scrollock.lock(scrollockCore, [
                                    targetElement1,
                                    targetElement2
                                  ]);
                              Core$Scrollock.unlock(scrollockCore, [
                                    targetElement1,
                                    targetElement2
                                  ]);
                              var __x = expect(Caml_array.get(Jest.MockJs.calls(Caml_option.valFromOption(match)), 0));
                              return Jest.Expect.toEqual([
                                          targetElement1,
                                          targetElement2
                                        ], __x);
                            }));
                      Jest.test("Is called with all locked targetElements after clear", (function (param) {
                              var match = mockOnLockTargetsRemoveRef.contents;
                              var match$1 = scrollockCoreRef.contents;
                              var match$2 = targetElement1Ref.contents;
                              if (match === undefined) {
                                return Jest.fail("Prepare stage failed");
                              }
                              if (match$1 === undefined) {
                                return Jest.fail("Prepare stage failed");
                              }
                              if (match$2 === undefined) {
                                return Jest.fail("Prepare stage failed");
                              }
                              var targetElement1 = Caml_option.valFromOption(match$2);
                              var scrollockCore = Caml_option.valFromOption(match$1);
                              var targetElement2 = document.createElement("div");
                              Core$Scrollock.lock(scrollockCore, [
                                    targetElement1,
                                    targetElement2
                                  ]);
                              Core$Scrollock.clear(scrollockCore);
                              var __x = expect(Caml_array.get(Jest.MockJs.calls(Caml_option.valFromOption(match)), 0));
                              return Jest.Expect.toEqual([
                                          targetElement1,
                                          targetElement2
                                        ], __x);
                            }));
                      Jest.test("Is called with the only instance of targetElement if there are multiple same instances in the unlock function", (function (param) {
                              var match = mockOnLockTargetsRemoveRef.contents;
                              var match$1 = scrollockCoreRef.contents;
                              var match$2 = targetElement1Ref.contents;
                              if (match === undefined) {
                                return Jest.fail("Prepare stage failed");
                              }
                              if (match$1 === undefined) {
                                return Jest.fail("Prepare stage failed");
                              }
                              if (match$2 === undefined) {
                                return Jest.fail("Prepare stage failed");
                              }
                              var targetElement1 = Caml_option.valFromOption(match$2);
                              var scrollockCore = Caml_option.valFromOption(match$1);
                              Core$Scrollock.lock(scrollockCore, [targetElement1]);
                              Core$Scrollock.unlock(scrollockCore, [
                                    targetElement1,
                                    targetElement1
                                  ]);
                              var __x = expect(Caml_array.get(Jest.MockJs.calls(Caml_option.valFromOption(match)), 0));
                              return Jest.Expect.toEqual([targetElement1], __x);
                            }));
                      return Jest.test("Isn't called the second time if the targetElement is already unlocked", (function (param) {
                                    var match = mockOnLockTargetsRemoveRef.contents;
                                    var match$1 = scrollockCoreRef.contents;
                                    var match$2 = targetElement1Ref.contents;
                                    if (match === undefined) {
                                      return Jest.fail("Prepare stage failed");
                                    }
                                    if (match$1 === undefined) {
                                      return Jest.fail("Prepare stage failed");
                                    }
                                    if (match$2 === undefined) {
                                      return Jest.fail("Prepare stage failed");
                                    }
                                    var targetElement1 = Caml_option.valFromOption(match$2);
                                    var scrollockCore = Caml_option.valFromOption(match$1);
                                    Core$Scrollock.lock(scrollockCore, [targetElement1]);
                                    Core$Scrollock.unlock(scrollockCore, [targetElement1]);
                                    Core$Scrollock.unlock(scrollockCore, [targetElement1]);
                                    var __x = expect(Jest.MockJs.calls(Caml_option.valFromOption(match)).length);
                                    return Jest.Expect.toBe(1, __x);
                                  }));
                    }));
      }));

var test = Jest.test;

var describe = Jest.describe;

var fail = Jest.fail;

export {
  test ,
  describe ,
  beforeEach$1 as beforeEach,
  fail ,
  mock ,
  expect ,
  
}
/*  Not a pure module */
